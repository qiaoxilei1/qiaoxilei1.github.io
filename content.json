{"pages":[],"posts":[{"title":"base64编解码c++实现","text":"这两天在为公司的框架添加一个Base64加解密的模块，于是就想分享一下Base64的原理及自己的C++实现。 Base64简介Base64是一种字节编码方式，一个字节可表示256个值，那么ASCII中0x20 ~ 0x7E是可打印字符，也就是说只有这么些范围的字符打印出来是可见的。Base64编码就是把字节转化成ASCII码中可打印的字符(Base64编码是从二进制到可见字符的过程)。它是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。 Base64应用 由于二进制的一些字符在网络协议中属于控制字符，不能直接传送，因此需要用Base64编码之后传输，编码之后传输的是一些很普通的ASCII字符。 Base64常用于邮件编码，当邮件中有二进制数据时，就要编码转换。 图片的编码 Url中有二进制数据，这个时候需要Base64编码(Web安全的Base64) 可以进行简单的加密，Base64的编解码规则是透明的，因此用Base64加密时要加盐。 Base64原理用一句话来说明Base64编码的原理：“把3个字节变成4个字节”。 这么说吧，3个字节一共24个bit，把这24个bit依次分成4个组，每个组6个bit，再把这6个bit塞到一个字节中去(最高位补两个0就变成8个bit)，就会变成4个字节。没了。 因为6个bit最多能表示26=6426=64，也就是说Base64编码出来的字符种类只有64个，这也是Base64名字的由来。 那我们就要从ASCII中0x20 ~ 0x7E是可打印字符选出64个普通的ASCII字符 下面就是映射表(来自维基百科)： 加密之后形成的密文长度一定是4的倍数，且字符串中的字符一定要在映射表中，或者字符为=，还有，只可能有一个=或一个==。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;ctime&gt; //base64 编解码函数声明std::string b64encodestring(const std::string &amp;strString); //对 ASCII 字符串进行 base64 编码std::string b64decodestring(const std::string &amp;strString); //对 base64 编码后的字符串进行解码 //base64 编解码函数实现/*** @brief 对 ASCII 字符串进行 base64 编码** @param strString 待编码的字符串** @return srs::string 返回编码后的字符串** @note 对于字符串中含有非 ASCII 字符串型的字符, 代码将抛出 std::string 型异常, 请捕获*/std::string b64encodestring(const std::string &amp;strString){ int nByteSrc = strString.length(); std::string pszSource = strString; int i = 0; for(i; i &lt; nByteSrc; i++) if( pszSource[i] &lt; 0 || pszSource[i] &gt; 127 ) throw \"can not encode Non-ASCII characters\"; const char *enkey = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; std::string pszEncode(nByteSrc*4/3 + 4, '\\0'); int nLoop = nByteSrc %3 == 0 ? nByteSrc : nByteSrc - 3; int n = 0; for(i=0; i &lt; nLoop; i+=3 ) { pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((pszSource[i+1] &amp; 0xF0)&gt;&gt;4)]; pszEncode[n+2] = enkey[((pszSource[i+1] &amp; 0x0f)&lt;&lt;2) | ((pszSource[i+2] &amp; 0xc0 )&gt;&gt;6)]; pszEncode[n+3] = enkey[pszSource[i+2] &amp; 0x3F]; n += 4; } switch(nByteSrc%3) { case 0: pszEncode[n] = '\\0'; break; case 1: pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((0&amp;0xf0)&gt;&gt;4)]; pszEncode[n+2] = '='; pszEncode[n+3] = '='; pszEncode[n+4] = '\\0'; break; case 2: pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((pszSource[i+1]&amp;0xf0)&gt;&gt;4)]; pszEncode[n+2] = enkey[(( pszSource[i+1]&amp;0xf)&lt;&lt;2 ) | ((0&amp;0xc0)&gt;&gt;6)]; pszEncode[n+3] = '='; pszEncode[n+4] = '\\0'; break; } return pszEncode.c_str();} /*** @brief 对 base64 编码后的字符串进行解码** @param strString 待解码的字符串** @return std::string 返回解码后的字符串** @note 对于非base64编码的字符串或已损坏的base64字符串进行解码会抛出 std::string 型异常, 请捕获*/std::string b64decodestring(const std::string &amp;strString){ int nByteSrc = strString.length(); std::string pszSource = strString; const int dekey[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, // '+' -1, -1, -1, 63, // '/' 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // '0'-'9' -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // 'A'-'Z' -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // 'a'-'z' }; if(nByteSrc%4 != 0) throw \"bad base64 string\"; std::string pszDecode(nByteSrc*3/4+4, '\\0'); int nLoop = pszSource[nByteSrc-1] == '=' ? nByteSrc - 4 : nByteSrc; int b[4]; int i = 0, n = 0; for(i = 0; i &lt; nLoop; i += 4 ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; b[2] = dekey[pszSource[i+2]]; b[3] = dekey[pszSource[i+3]]; if(b[0] == -1 || b[1] == -1 || b[2] == -1 || b[3] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = ((b[1] &amp; 0xf) &lt;&lt; 4) | ((b[2] &amp; 0x3c) &gt;&gt; 2); pszDecode[n+2] = ((b[2] &amp; 0x3) &lt;&lt; 6) | b[3]; n+=3; } if( pszSource[nByteSrc-1] == '=' &amp;&amp; pszSource[nByteSrc-2] == '=' ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; if(b[0] == -1 || b[1] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = '\\0'; } if( pszSource[nByteSrc-1] == '=' &amp;&amp; pszSource[nByteSrc-2] != '=' ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; b[2] = dekey[pszSource[i+2]]; if(b[0] == -1 || b[1] == -1 || b[2] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = ((b[1] &amp; 0xf) &lt;&lt; 4) | ((b[2] &amp; 0x3c) &gt;&gt; 2); pszDecode[n+2] = '\\0'; } if( pszSource[nByteSrc-1] != '=' &amp;&amp; pszSource[nByteSrc-2] != '=' ) pszDecode[n] = '\\0'; return pszDecode;} //测试int main(){ ///编码测试 std::string str1 = \"Hello, world!\"; std::cout &lt;&lt; \"对Hello, world!进行base64编码: \" &lt;&lt; b64encodestring(str1) &lt;&lt; std::endl; ///解码测试 std::string str2 = \"SGVsbG8sIHdvcmxkIQ==\"; std::cout &lt;&lt; \"对SGVsbG8sIHdvcmxkIQ==进行base64解码: \" &lt;&lt; b64decodestring(str2) &lt;&lt; std::endl; ///编码耗时测试 std::string str3(10000000, 'A'); //生成 10000000 长的字符串 std::cout &lt;&lt; std::endl &lt;&lt; \"对 10000000 长的字符串进行编码耗时测试..\" &lt;&lt; std::endl; size_t t0 = clock(); //编码计时开始 b64encodestring(str3); std::cout &lt;&lt; \"测试结束, 耗时 \" &lt;&lt; clock() - t0 &lt;&lt; \"ms\" &lt;&lt; std::endl; ///解码耗时测试 std::string str4 = b64encodestring(str3); //得到长度为 10000000 的字符串base64编码后的字符串 std::cout &lt;&lt; std::endl &lt;&lt; \"对 \" &lt;&lt; str4.length() &lt;&lt; \" 长的base64字符串进行解码耗时测试..\" &lt;&lt; std::endl; size_t t1 = clock(); //解码计时开始 b64decodestring(str3); std::cout &lt;&lt; \"测试结束, 耗时 \" &lt;&lt; clock() - t1 &lt;&lt; \"ms\" &lt;&lt; std::endl; return 0;}","link":"/2019/12/30/base64%E7%BC%96%E8%A7%A3%E7%A0%81c-%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"}]}