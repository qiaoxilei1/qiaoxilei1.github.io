{"pages":[],"posts":[{"title":"base64编解码c++实现","text":"这两天在为公司的框架添加一个Base64加解密的模块，于是就想分享一下Base64的原理及自己的C++实现。 Base64简介Base64是一种字节编码方式，一个字节可表示256个值，那么ASCII中0x20 ~ 0x7E是可打印字符，也就是说只有这么些范围的字符打印出来是可见的。Base64编码就是把字节转化成ASCII码中可打印的字符(Base64编码是从二进制到可见字符的过程)。它是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。 Base64应用 由于二进制的一些字符在网络协议中属于控制字符，不能直接传送，因此需要用Base64编码之后传输，编码之后传输的是一些很普通的ASCII字符。 Base64常用于邮件编码，当邮件中有二进制数据时，就要编码转换。 图片的编码 Url中有二进制数据，这个时候需要Base64编码(Web安全的Base64) 可以进行简单的加密，Base64的编解码规则是透明的，因此用Base64加密时要加盐。 Base64原理用一句话来说明Base64编码的原理：“把3个字节变成4个字节”。 这么说吧，3个字节一共24个bit，把这24个bit依次分成4个组，每个组6个bit，再把这6个bit塞到一个字节中去(最高位补两个0就变成8个bit)，就会变成4个字节。没了。 因为6个bit最多能表示26=6426=64，也就是说Base64编码出来的字符种类只有64个，这也是Base64名字的由来。 那我们就要从ASCII中0x20 ~ 0x7E是可打印字符选出64个普通的ASCII字符 下面就是映射表(来自维基百科)： 加密之后形成的密文长度一定是4的倍数，且字符串中的字符一定要在映射表中，或者字符为=，还有，只可能有一个=或一个==。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;ctime&gt; //base64 编解码函数声明std::string b64encodestring(const std::string &amp;strString); //对 ASCII 字符串进行 base64 编码std::string b64decodestring(const std::string &amp;strString); //对 base64 编码后的字符串进行解码 //base64 编解码函数实现/*** @brief 对 ASCII 字符串进行 base64 编码** @param strString 待编码的字符串** @return srs::string 返回编码后的字符串** @note 对于字符串中含有非 ASCII 字符串型的字符, 代码将抛出 std::string 型异常, 请捕获*/std::string b64encodestring(const std::string &amp;strString){ int nByteSrc = strString.length(); std::string pszSource = strString; int i = 0; for(i; i &lt; nByteSrc; i++) if( pszSource[i] &lt; 0 || pszSource[i] &gt; 127 ) throw \"can not encode Non-ASCII characters\"; const char *enkey = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; std::string pszEncode(nByteSrc*4/3 + 4, '\\0'); int nLoop = nByteSrc %3 == 0 ? nByteSrc : nByteSrc - 3; int n = 0; for(i=0; i &lt; nLoop; i+=3 ) { pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((pszSource[i+1] &amp; 0xF0)&gt;&gt;4)]; pszEncode[n+2] = enkey[((pszSource[i+1] &amp; 0x0f)&lt;&lt;2) | ((pszSource[i+2] &amp; 0xc0 )&gt;&gt;6)]; pszEncode[n+3] = enkey[pszSource[i+2] &amp; 0x3F]; n += 4; } switch(nByteSrc%3) { case 0: pszEncode[n] = '\\0'; break; case 1: pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((0&amp;0xf0)&gt;&gt;4)]; pszEncode[n+2] = '='; pszEncode[n+3] = '='; pszEncode[n+4] = '\\0'; break; case 2: pszEncode[n] = enkey[pszSource[i]&gt;&gt;2]; pszEncode[n+1] = enkey[((pszSource[i]&amp;3)&lt;&lt;4) | ((pszSource[i+1]&amp;0xf0)&gt;&gt;4)]; pszEncode[n+2] = enkey[(( pszSource[i+1]&amp;0xf)&lt;&lt;2 ) | ((0&amp;0xc0)&gt;&gt;6)]; pszEncode[n+3] = '='; pszEncode[n+4] = '\\0'; break; } return pszEncode.c_str();} /*** @brief 对 base64 编码后的字符串进行解码** @param strString 待解码的字符串** @return std::string 返回解码后的字符串** @note 对于非base64编码的字符串或已损坏的base64字符串进行解码会抛出 std::string 型异常, 请捕获*/std::string b64decodestring(const std::string &amp;strString){ int nByteSrc = strString.length(); std::string pszSource = strString; const int dekey[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, // '+' -1, -1, -1, 63, // '/' 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // '0'-'9' -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // 'A'-'Z' -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // 'a'-'z' }; if(nByteSrc%4 != 0) throw \"bad base64 string\"; std::string pszDecode(nByteSrc*3/4+4, '\\0'); int nLoop = pszSource[nByteSrc-1] == '=' ? nByteSrc - 4 : nByteSrc; int b[4]; int i = 0, n = 0; for(i = 0; i &lt; nLoop; i += 4 ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; b[2] = dekey[pszSource[i+2]]; b[3] = dekey[pszSource[i+3]]; if(b[0] == -1 || b[1] == -1 || b[2] == -1 || b[3] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = ((b[1] &amp; 0xf) &lt;&lt; 4) | ((b[2] &amp; 0x3c) &gt;&gt; 2); pszDecode[n+2] = ((b[2] &amp; 0x3) &lt;&lt; 6) | b[3]; n+=3; } if( pszSource[nByteSrc-1] == '=' &amp;&amp; pszSource[nByteSrc-2] == '=' ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; if(b[0] == -1 || b[1] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = '\\0'; } if( pszSource[nByteSrc-1] == '=' &amp;&amp; pszSource[nByteSrc-2] != '=' ) { b[0] = dekey[pszSource[i]]; b[1] = dekey[pszSource[i+1]]; b[2] = dekey[pszSource[i+2]]; if(b[0] == -1 || b[1] == -1 || b[2] == -1) throw \"bad base64 string\"; pszDecode[n] = (b[0] &lt;&lt; 2) | ((b[1] &amp; 0x30) &gt;&gt; 4); pszDecode[n+1] = ((b[1] &amp; 0xf) &lt;&lt; 4) | ((b[2] &amp; 0x3c) &gt;&gt; 2); pszDecode[n+2] = '\\0'; } if( pszSource[nByteSrc-1] != '=' &amp;&amp; pszSource[nByteSrc-2] != '=' ) pszDecode[n] = '\\0'; return pszDecode;} //测试int main(){ ///编码测试 std::string str1 = \"Hello, world!\"; std::cout &lt;&lt; \"对Hello, world!进行base64编码: \" &lt;&lt; b64encodestring(str1) &lt;&lt; std::endl; ///解码测试 std::string str2 = \"SGVsbG8sIHdvcmxkIQ==\"; std::cout &lt;&lt; \"对SGVsbG8sIHdvcmxkIQ==进行base64解码: \" &lt;&lt; b64decodestring(str2) &lt;&lt; std::endl; ///编码耗时测试 std::string str3(10000000, 'A'); //生成 10000000 长的字符串 std::cout &lt;&lt; std::endl &lt;&lt; \"对 10000000 长的字符串进行编码耗时测试..\" &lt;&lt; std::endl; size_t t0 = clock(); //编码计时开始 b64encodestring(str3); std::cout &lt;&lt; \"测试结束, 耗时 \" &lt;&lt; clock() - t0 &lt;&lt; \"ms\" &lt;&lt; std::endl; ///解码耗时测试 std::string str4 = b64encodestring(str3); //得到长度为 10000000 的字符串base64编码后的字符串 std::cout &lt;&lt; std::endl &lt;&lt; \"对 \" &lt;&lt; str4.length() &lt;&lt; \" 长的base64字符串进行解码耗时测试..\" &lt;&lt; std::endl; size_t t1 = clock(); //解码计时开始 b64decodestring(str3); std::cout &lt;&lt; \"测试结束, 耗时 \" &lt;&lt; clock() - t1 &lt;&lt; \"ms\" &lt;&lt; std::endl; return 0;}","link":"/2019/12/30/base64%E7%BC%96%E8%A7%A3%E7%A0%81c-%E5%AE%9E%E7%8E%B0/"},{"title":"用数组实现的环形无锁队列","text":"根据公司要求，实现无锁环形队列，利用c++11新特性原子操作，在多生产者多消费者模式下，可以保证线程安全，头文件如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#ifndef _MPMC_QUEUE_H_#define _MPMC_QUEUE_H_#include &lt;atomic&gt;#include &lt;cassert&gt;#include &lt;limits&gt;#include &lt;memory&gt;#include &lt;new&gt; // std::hardware_destructive_interference_size#include &lt;stdexcept&gt;template &lt;typename T&gt;class MPMCQueue{public: explicit MPMCQueue(const size_t capacity)//构造，入参是size : capacity_(capacity), head_(0), tail_(0) { if (capacity_ &lt; 1) { throw std::invalid_argument(\"capacity &lt; 1\"); } size_t space = capacity * sizeof(Slot) + kCacheLineSize - 1; buf_ = malloc(space); if (buf_ == nullptr) { throw std::bad_alloc(); } void *buf = buf_; slots_ = reinterpret_cast&lt;Slot *&gt;( std::align(kCacheLineSize, capacity * sizeof(Slot), buf, space)); if (slots_ == nullptr) { free(buf_); throw std::bad_alloc(); } for (size_t i = 0; i &lt; capacity_; ++i) { new (&amp;slots_[i]) Slot(); } static_assert(sizeof(MPMCQueue&lt;T&gt;) % kCacheLineSize == 0, \"MPMCQueue&lt;T&gt; size must be a multiple of cache line size to \" \"prevent false sharing between adjacent queues\"); static_assert(sizeof(Slot) % kCacheLineSize == 0, \"Slot size must be a multiple of cache line size to prevent \" \"false sharing between adjacent slots\"); assert(reinterpret_cast&lt;size_t&gt;(slots_) % kCacheLineSize == 0 &amp;&amp; \"slots_ array must be aligned to cache line size to prevent false \" \"sharing between adjacent slots\"); assert(reinterpret_cast&lt;char *&gt;(&amp;tail_) - reinterpret_cast&lt;char *&gt;(&amp;head_) &gt;= static_cast&lt;std::ptrdiff_t&gt;(kCacheLineSize) &amp;&amp; \"head and tail must be a cache line apart to prevent false sharing\"); } ~MPMCQueue() noexcept { for (size_t i = 0; i &lt; capacity_; ++i) { slots_[i].~Slot(); } free(buf_); } MPMCQueue(const MPMCQueue &amp;) = delete; //删除默认拷贝构造函数，即不能进行默认拷贝 MPMCQueue &amp;operator=(const MPMCQueue &amp;) = delete; //删除默认赋值运算符 template &lt;typename... Args&gt; //可变参数模板 void emplace(Args &amp;&amp;... args) noexcept//满队列时阻塞，使用普通构造 { static_assert(std::is_nothrow_constructible&lt;T, Args &amp;&amp;...&gt;::value, \"T must be nothrow constructible with Args&amp;&amp;...\"); auto const head = head_.fetch_add(1); auto &amp;slot = slots_[idx(head)]; while (turn(head) * 2 != slot.turn.load(std::memory_order_acquire)) ; slot.construct(std::forward&lt;Args&gt;(args)...); slot.turn.store(turn(head) * 2 + 1, std::memory_order_release); } template &lt;typename... Args&gt; bool try_emplace(Args &amp;&amp;... args) noexcept//不阻塞，失败时返回false { static_assert(std::is_nothrow_constructible&lt;T, Args &amp;&amp;...&gt;::value, \"T must be nothrow constructible with Args&amp;&amp;...\"); auto head = head_.load(std::memory_order_acquire); for (;;) { auto &amp;slot = slots_[idx(head)]; if (turn(head) * 2 == slot.turn.load(std::memory_order_acquire)) { if (head_.compare_exchange_strong(head, head + 1)) { slot.construct(std::forward&lt;Args&gt;(args)...); slot.turn.store(turn(head) * 2 + 1, std::memory_order_release); return true; } } else { auto const prevHead = head; head = head_.load(std::memory_order_acquire); if (head == prevHead) { return false; } } } } void push(const T &amp;v) noexcept {//拷贝构造，阻塞 static_assert(std::is_nothrow_copy_constructible&lt;T&gt;::value, \"T must be nothrow copy constructible\"); emplace(v); } template &lt;typename P,typename = typename std::enable_if&lt;std::is_nothrow_constructible&lt;T, P &amp;&amp;&gt;::value&gt;::type&gt; void push(P &amp;&amp;v) noexcept {//拷贝构造，阻塞 emplace(std::forward&lt;P&gt;(v)); } bool try_push(const T &amp;v) noexcept {//拷贝构造，不阻塞 static_assert(std::is_nothrow_copy_constructible&lt;T&gt;::value, \"T must be nothrow copy constructible\"); return try_emplace(v); } template &lt;typename P,typename = typename std::enable_if&lt;std::is_nothrow_constructible&lt;T, P &amp;&amp;&gt;::value&gt;::type&gt; bool try_push(P &amp;&amp;v) noexcept {return try_emplace(std::forward&lt;P&gt;(v));} void pop(T &amp;v) noexcept//拷贝或者移动输出，阻塞 { auto const tail = tail_.fetch_add(1); auto &amp;slot = slots_[idx(tail)]; while (turn(tail) * 2 + 1 != slot.turn.load(std::memory_order_acquire)) ; v = slot.move(); slot.destroy(); slot.turn.store(turn(tail) * 2 + 2, std::memory_order_release); } bool try_pop(T &amp;v) noexcept//拷贝或者移动输出，不阻塞，返回失败 { auto tail = tail_.load(std::memory_order_acquire); for (;;) { auto &amp;slot = slots_[idx(tail)]; if (turn(tail) * 2 + 1 == slot.turn.load(std::memory_order_acquire)) { if (tail_.compare_exchange_strong(tail, tail + 1)) { v = slot.move(); slot.destroy(); slot.turn.store(turn(tail) * 2 + 2, std::memory_order_release); return true; } } else { auto const prevTail = tail; tail = tail_.load(std::memory_order_acquire); if (tail == prevTail) { return false; } } } }private: static_assert(std::is_nothrow_copy_assignable&lt;T&gt;::value || std::is_nothrow_move_assignable&lt;T&gt;::value, \"T must be nothrow copy or move assignable\"); static_assert(std::is_nothrow_destructible&lt;T&gt;::value, \"T must be nothrow destructible\"); constexpr size_t idx(size_t i) const noexcept { return i % capacity_; } constexpr size_t turn(size_t i) const noexcept { return i / capacity_; }#ifdef __cpp_lib_hardware_interference_size static constexpr size_t kCacheLineSize = std::hardware_destructive_interference_size;#else static constexpr size_t kCacheLineSize = 64;#endif struct Slot { //辅助容器，包装对象，可以字节对齐 ~Slot() noexcept { if (turn &amp; 1) { destroy(); } } template &lt;typename... Args&gt; void construct(Args &amp;&amp;... args) noexcept { static_assert(std::is_nothrow_constructible&lt;T, Args &amp;&amp;...&gt;::value, \"T must be nothrow constructible with Args&amp;&amp;...\"); new (&amp;storage) T(std::forward&lt;Args&gt;(args)...); } void destroy() noexcept { static_assert(std::is_nothrow_destructible&lt;T&gt;::value, \"T must be nothrow destructible\"); reinterpret_cast&lt;T *&gt;(&amp;storage)-&gt;~T(); } T &amp;&amp;move() noexcept { return reinterpret_cast&lt;T &amp;&amp;&gt;(storage); } alignas(kCacheLineSize)std::atomic&lt;size_t&gt; turn = { 0 }; typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type storage; };private: const size_t capacity_; Slot *slots_; void *buf_; alignas(kCacheLineSize)std::atomic&lt;size_t&gt; head_; alignas(kCacheLineSize)std::atomic&lt;size_t&gt; tail_;};#endif //_MPMC_QUEUE_H_ 测试文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include \"stdafx.h\"#include \"mpmcqueue.h\"#include \"stdio.h\"#include &lt;time.h&gt;#include &lt;thread&gt;using namespace std;int main(){ MPMCQueue&lt;int&gt; q(100); std::thread threads[4]; clock_t clockBegin, clockEnd; clockBegin = clock(); for (int i = 0; i != 2; ++i) { threads[i] = std::thread([&amp;](int i) { for (int j = 0; j != 50; ++j) { q.push(i * 10 + j); printf(\"thread %d push:%d\\n\",i, i*10+j); } }, i); } for (int i = 2; i != 4; ++i) { threads[i] = std::thread([&amp;]() { int item; for (int j = 0; j != 50; ++j) { q.pop(item); printf(\"thread %d pop:%d\\n\",i, item); } }); } for (int i = 0; i != 4; ++i) { threads[i].join(); } clockEnd = clock(); printf(\"%d\\n\", clockEnd - clockBegin); return 0;}","link":"/2019/12/30/%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%8E%AF%E5%BD%A2%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"},{"title":"c++文件读写操作","text":"ofstream头文件： 1234567ofstream out(\"out.txt\");if(out.is_open()){ out &lt;&lt; \"This is a line\\n\" ; out &lt;&lt; \"This is another line\\n\"; out.close();} 文件不存在时会自动创建文件当文件读写操作完成之后，我们必须将文件关闭以使文件重新变为可访问的。成员函数close()，它负责将缓存中的数据排放出来并关闭文件。这个函数一旦被调用，原先的流对象就可以被用来打开其它的文件了，这个文件也就可以重新被其它的进程所访问了。为防止流对象被销毁时还联系着打开的文件，析构函数将会自动调用关闭函数close。为了原来的内容不被覆盖，需要显示指定ofstream::app 1234567ofstream out(\"out.txt\", ofstream::app);if(out.is_open()){ out &lt;&lt; \"This is a line\\n\" ; out &lt;&lt; \"This is another line\\n\"; out.close();} ifstream头文件： (1) 读取方式：逐行读取，将行读入字符串，行只见那用回车换行区分 12345678910111213string str;ifstream in(&quot;out.txt&quot;);if(in.is_open()){ while(!in.eof()) { getline(in.str); cout &lt;&lt; str &lt;&lt; endl; }}else{ cout &lt;&lt; &quot;open file error&quot; &lt;&lt; endl;}","link":"/2019/12/31/c-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/"},{"title":"推荐一本书：计算机的心智：操作系统之哲学原理","text":"对于我们这些非计算机专业的学生来说，能够从计算机的底层理解计算机的运算过程其实是需要花费很大的努力，尤其是没有老师带，没有同学交流，只能自己一个人去摸索的情况下。因为要学习计算机的基础知识，我从网上了解到基本上需要学习四本基础知识课程：计算机组成原理、数据结构和算法、计算机操作系统、计算机网络。这四门课程都有很多非常经典的书籍，尤其是外文书籍。但是对于国内的群众来说，时间不那么充足的情况下，阅读外文的可操作性不那么可观。我阅读过《现代操作系统》，不过感觉晦涩难懂，抓不住重点，不能形成一个明确的知识体系，而这本《计算机的心智：操作系统之哲学原理》从整体上对整个操作系统讲解的很清楚明白。当你理解了每个部分的功能，你就对整个系统有个全面初步的了解，这时候你在去深入的了解一些细节，效果会更好。所以，我建议首先阅读每一篇的开篇时的那一小段话，一定要全部阅读完之后，在仔细的思考一下，你就能从宏观上把握操作系统具体是干什么用的。然后有了整体的把握之后再去详细看每一篇的细节。基本上，计算机的所有工作都是围绕CPU进行的，内存和外存为CPU提供资源。在这里，我先把每一篇的前言部分全部全文摘录下来，希望能够加深自己对操作系统整体的理解和把握。 计算机的心智：操作系统之哲学原理前言CPU管理（进程与线程）、内存管理（虚拟内存）、外村管理（文件系统）、I/O管理（输入与输出）等操作系统的核心机制不外乎是资源的管理，它们都遵循着一切人类资源管理的基本原则，即如何有效地发掘资源、监控资源、分配资源和回收资源。除了提供管理的功能外，操作系统还需要保证自己的正常运转，即它必须尽力使自身不发生失效或崩溃，因为这是提供其他一切功能的基础。这与人类把确保自身健康生活作为开发利用资源的前提是一个道理。如果我们把握了资源的根本属性，即资源管理必然涉及共享和竞争的管理，理解了操作系统必须首先保障自己的正常运转，就会理解操作系统的一切行为。前者指引着操作系统功能的设计与进化，后者推动着操作系统可靠性地演变。资源管理也好，保证自身的正确性也好，它们都有着根本的线索。这条根本线索就是人类在长期的生活实践中摸索出来的管理社会和保障自身安全的各种办法。这些办法是随着人类哲学思维的变化而改进的。因此，只要明白了人类的哲学思维，就能明白操作系统所遵循的哲学原理，进而明白整个操作系统的设计与构造。除了使操作系统易于理解外，从哲学的层面阐述操作系统的原理还有如下好处： 操作系统可以变化，但支持其存在的哲学原理是不变的。这样，本书的内容可以在操作系统不断演变的环境下保持有效，而不会像其他书的内容，随着时间的推移而过时。 对于很多人来说，操作系统所采取的机制、策略和手段看上去十分枯燥，如果从哲学原理上给它们赋予人性的特点，这些机制、策略和手段便不在枯燥。通过将人生哲学与操作系统联系起来，从操作系统哲学原理的层次阐述操作系统的核心技术，就能够理解掌握操作系统的精髓。 第一篇：基础原理篇对于任何一门课程来说，首先探讨的问题就是这门课的主题到底是什么？对于刚接触操作系统的入门者来说，自然想到的问题当然也会是操作系统到底是什么东西。回答这个问题是本篇的职责。此外，操作系统作为计算机的核心控制系统，它在计算机运行过程中扮演什么角色？它的来历是什么？它有一些什么基本概念？我们应该如何看待操作系统？它是如何参与到程序的执行过程中的？这些也是学习操作系统需要了解的基本问题。本书的基础原理篇就是真的上述问题而写成。它对这些问题进行解答和讨论，并为我们接下来介绍操作系统的核心功能部件打下基础和铺垫。本篇最为重要的核心思想是操作系统在计算机运行过程中扮演的角色：魔术师和管理者。魔术师将丑陋变得美好，将没有变为有，将少变为多：而管理者则对所有计算机资源进行管理以达到公平和效率的“双料”境界。对操作系统这两个角色的理解将非常有助于对进程、线程、虚拟内存、文件系统和输入输出系统的掌握。 第二篇：进程原理篇有了基础原理篇的铺垫，我们就可以进入到操作系统核心功能部件的讲解了。计算机，顾名思义，是用来计算的。而进行计算的关键部件是计算机的芯片，即CPU。CPU能够按照一定的顺序进行正确计算是在一个指挥者的控制之下完成的。这个指挥者就是操作系统，而操作系统对CPU进行管理和施行魔法的手段就是进程和线程。因此，对进程和线程这些施法道具进行阐述对理解操作系统自然十分重要，对其进行管理也就理所当然地成为操作系统的一个关键职责。本篇最重要的内容是并发。因为要并发，我们发明了进程，又进一步发明了线程，只不过进程和线程的并发层次不同。进程属于在处理器这一层次上提供并发的抽象，线程则属于在进程这个层次上再提供一层并发的抽象。如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，只不过是指令集并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发。 第三篇：内存原理篇计算机的一个基本功能是计算。计算机除了需要使用硬件以外，还要有两种信息：数据和代码，他们是计算硬件CPU的输入，没有这些，CPU也是巧妇难为无米之炊-无法进行计算。那么这些东西从哪来呢？或者说这些信息存放在什么地方呢？显然，存放这些东西的地方需要能够很快地将数据读出写入，以便能够与CPU合作完成计算机被赋予的功能。这个地方不是别的，就是计算机的主存储器，通常简称为内存。对内存进行管理是操作系统对CPU进行管理的重要支持。本篇最为重要的核心思想是虚拟内存。通过这种机制，操作系统将内存的容量扩增或无限扩大，将内存的访问速度大幅度提高，而其使用的语料却很简单：一点点缓存，一些主存和便宜的磁盘；其采用的机制也简单至极：动态地址翻译！ 第四篇：文件原理篇在上一篇讲过，计算机运行时所需的数据和代码从主存储器或者内存而来。如果计算机不在运行状态时，这些数据和代码保持在何处呢？我们当然可以试一下内存。但问题是内存不是持久性的存储介质，它是进程运行过程中临时分配的存储空间。一旦进程结束运行，其所占内存空间就会被释放，存放在里面的数据和代码也将消失。而且，内存需要电能支持才能保持数据（指一般的内存），一旦断电，所有数据都将丢失。因此，数据和代码想要长久保持，就需要一个更为持久的地方来存放，这个持久地方就是磁盘。而对磁盘进行管理就是操作系统的另一个重要使命。如果管理得当，磁盘、内存和CPU将协作完成计算机的使命。计算机管理磁盘采用的手段或者抽象就是文件系统，这是本篇讲解的关键主题。本篇最重要的核心是文件夹及其实现，因为它是文件系统运作的根本。通过文件夹，我们才能找到我们需要的文件，完成从抽象到现实的转换。 第五篇：IO原理篇有了计算，又有了存放数据的临时和永久地方，似乎计算机需要的一切都已经具备。但这是真的吗？我们知道，发明计算机的目的是让计算机为人类服务，而计算机要为人类服务就得有一种办法与人类进行沟通或者交互。而实现这种交互的手段就是计算机的输入和输出。一台没有输入和输出的计算机，其CPU、内存和磁盘在强大，对人们也并无太大用处，甚至说是毫无用处。就像一个人一样，如果其能力再强，大脑再聪明，只要他与外界的沟通渠道（听说读写）被打断或有缺陷，就会被世人看做一个无用的人。因此，要想让计算机真的有用，就得有输入和输出。而操作系统既然是计算机的掌控者，当然也需要对输入输出进行掌控。本篇即对计算机与外界进行沟通的输入与输出机制进行详解。本篇最为重要的核心是输入输出的硬件模式与软件模式，及这两个模式之间的对应关系。 第六篇：多核原理篇随着多核技术的流行，操作系统作为计算机的管理者，不得不增加对多核的管理功能。而从单核到多核，并不只是处理器或处理器核数量的简单变化，其对操作系统的影响是多方位的。首先，多核的出现对操作系统的进程和线程调度产生了直接影响。因为这个时候可以同时调度多个线程和进程进行执行。其次，在多核环境下，一条指令可以同时在多个核上面执行，就使得单核环境下的同步机制不一定运行正确。另外，多核的出现使得能耗的管理趋于重要。本篇最重要的概念就是多核之间的协调：即如何让多个核的计算能力相得弥彰，而不是相互抵消。从某种程度上说，多核之间的协调与前面讲过的进程或线程之间的协调具有相通性。而从另一个角度看，这种协调又是进程之间或线程之间协调的扩展和延续，因此，只要明白了线程之间的协调原理与机制，理解多核技术及其对操作系统的影响就是水到渠成的事情了。 第七篇：操作系统设计原理篇前面六大篇对操作系统的基本概念和各种机制进行了详细论述。虽然这些论述是分篇分章进行的，但它们之间并不是互相割裂的，而是有着内部的逻辑联系的。联系它们的纽带有多条。首先是操作系统作为计算机的管理者，需要对计算机的各个组成部分进行管理，这就导致了CPU管理、内存管理、磁盘管理、输入输出设备管理等操作系统功能的出现和相互关联。其次，操作系统作为魔术师，需要对计算机的各种硬件进行抽象和装扮，以使其显得更大、更快、更好、更容易使用。而这些从抽象就形成了进程线程、虚拟内存、文件系统、各种I/O模式等操作系统构造的出现。而这些构造之间也因操作系统魔术师的角色而互相联结起来。但除了管理和魔幻这两条共同的纽带外，操作系统能够各个部分海投一个联结纽带：其设计上所遵循的哲学原理。虽然CPU、内存、磁盘、输入输出等设备听上去相差很大，但对他们进行管理和抽象时所采用的策略却有很多相通点。本篇即对这些相通点或哲学原理进行讨论。本篇从高屋建瓴的角度对操作系统设计的十条哲学原理进行阐述。显然，操作系统的设计原理有很多，本篇选取的只是这诸多原理里面非常重要的十条。本篇最为重要的核心是不同的生活哲学将导致不同的操作系统设计与构造。只要真正理解了人生哲学，就真正明白了操作系统。","link":"/2020/01/02/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B9%A6%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%BF%83%E6%99%BA%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%93%B2%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"title":"核心已转储","text":"","link":"/2019/12/31/%E6%A0%B8%E5%BF%83%E5%B7%B2%E8%BD%AC%E5%82%A8/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"工作","slug":"工作","link":"/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}